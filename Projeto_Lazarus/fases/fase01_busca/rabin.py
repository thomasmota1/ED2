import time
import random
import unicodedata
from rich.console import Console
from rich.panel import Panel
from utils.core import narrar, fala, pausa, progresso_ritual, limpar_tela, esperar_enter

console = Console()

class FaseRabinTempoReal:
    def __init__(self):
        self.texto = (
            "= TRATADO DE CONVERGÃŠNCIA ZEPHYRIANA =\n"
            "SeÃ§Ã£o VII - A Instabilidade do NÃºcleo.\n"
            "â€˜Toda energia precisa vibrar em sintonia com o cÃ³digo que a originou.â€™\n"
            "Os antigos relatam que uma palavra de sintonia pode acalmar o NÃºcleo.\n"
            "Ela foi perdida entre ironias e repetiÃ§Ãµes; a pista fala em harmonia e frequÃªncia.\n"
            "...\n"
            "RESSONANCIA: Executar CompressÃ£o HarmÃ´nica. Aplicar algoritmo de Huffman.\n"
            "Indexar resultado com HASH-42. Transmitir ao NÃºcleo LexicÃ´nico.\n"
            "Evitar eco e repetiÃ§Ã£o. O silÃªncio Ã© estabilidade.\n"
            "...\n"
            "Fim do Tratado."
        )
        self.d = 256
        self.q = 101
        self.palavra_chave = "RESSONANCIA"

    def normalizar(self, texto):
        t = texto.upper()
        t = unicodedata.normalize("NFD", t)
        t = "".join(c for c in t if unicodedata.category(c) != "Mn")
        return t

    def hash_inicial(self, s, m):
        h = 0
        for i in range(m):
            h = (self.d * h + ord(s[i])) % self.q
        return h

    def animacao_hash(self, texto, padrao):
        console.print("\n[bold yellow] Iniciando calculo de hashes...[/bold yellow]")
        barras = ["â–â–‚â–ƒâ–„â–…â–†â–‡â–ˆ", "â–‚â–ƒâ–„â–…â–†â–‡â–ˆâ–‡", "â–ƒâ–„â–…â–†â–‡â–ˆâ–‡â–…", "â–„â–…â–†â–‡â–ˆâ–‡â–…â–„"]
        for i in range(8):
            bloco = random.choice(barras)
            console.print(f"[magenta]Rolando janela {i+1}...[/magenta] [dim]{bloco}[/dim]", end="\r")
            time.sleep(0.2)
        console.print("\n[bold green]âœ” Hashes iniciais calculados e sincronizados[/bold green]\n")
        pausa(0.5)

    def busca_rabin(self, texto, padrao):
        texto_n = self.normalizar(texto)
        padrao_n = self.normalizar(padrao)
        n, m = len(texto_n), len(padrao_n)
        if m > n:
            return [], 0.0
        h = pow(self.d, m - 1, self.q)
        p_hash = self.hash_inicial(padrao_n, m)
        t_hash = self.hash_inicial(texto_n, m)
        resultados = []
        tempo_inicio = time.perf_counter()
        for s in range(n - m + 1):
            if p_hash == t_hash:
                if texto_n[s:s + m] == padrao_n:
                    resultados.append(s)
            if s < n - m:
                t_hash = (self.d * (t_hash - ord(texto_n[s]) * h) + ord(texto_n[s + m])) % self.q
                if t_hash < 0:
                    t_hash += self.q
        tempo_total = time.perf_counter() - tempo_inicio
        return resultados, tempo_total

    def animacao_instavel(self, intensidade=6):
        for i in range(intensidade):
            offset = random.randint(0, 6)
            vazio = " " * offset
            console.print(vazio + Panel.fit("[bold red]âš  NÃºcleo instÃ¡vel . VibraÃ§Ã£o detectada[/bold red]", border_style="red"))
            time.sleep(0.12)
            limpar_tela()
        console.print(Panel.fit("[red]âš  Instabilidade crescente... ajuste a busca.[/red]", border_style="red"))
        pausa(0.6)

    def animacao_estabiliza(self):
        barras = ["â–â–‚â–ƒâ–„â–…â–†â–‡â–ˆ", "â–‚â–ƒâ–„â–…â–†â–‡â–ˆâ–‡", "â–ƒâ–„â–…â–†â–‡â–ˆâ–‡â–…", "â–„â–…â–†â–‡â–ˆâ–‡â–…â–„", "â–…â–†â–‡â–ˆâ–‡â–…â–„â–ƒ", "â–‡â–ˆâ–‡â–…â–„â–ƒâ–‚â–"]
        for i in range(len(barras)):
            console.print(Panel.fit(f"[green]Sintonia: {barras[i]}[/green]"))
            time.sleep(0.18)
        console.print(Panel.fit("[bold green]âœ” NÃºcleo estabilizado[/bold green]", border_style="green"))
        pausa(0.6)

    def analise_complexidade(self, n, m, tempo, sucesso):
        resultado = "SUCESSO" if sucesso else "FALHA"
        fala("Roric", "Calculando mÃ©tricas da varredura...")
        fala("Elara", f"Tamanho do texto: {n} | PadrÃ£o: {m}")
        fala("Kaelen", "Melhor caso aproximado: O(n + m). Rolamento de hash evita comparaÃ§Ãµes desnecessÃ¡rias.")
        fala("Lin", "Pior caso: O(n Ã— m) se houver muitos falsos ecos (colisÃµes).")
        console.print(Panel.fit(
            f"[bold yellow]ðŸ“Š MÃ©tricas Rabin-Karp ({resultado})[/bold yellow]\n"
            f"Tamanho do texto: {n}\n"
            f"Tamanho do padrÃ£o: {m}\n"
            f"Tempo de execuÃ§Ã£o: {tempo:.4f}s\n"
            f"Melhor caso: O(n + m)\n"
            f"Pior caso: O(n Ã— m)",
            border_style="yellow"
        ))
        pausa(0.8)

    def reacao_erro(self, tentativa, tentativas):
        opcoes = [
            [("Kaelen", f"'{tentativa.upper()}'? Isso... definitivamente nÃ£o soou em sintonia."),
             ("Elara", "Talvez se focÃ¡ssemos em algo mais... harmÃ´nico."),
             ("Roric", "Ou menos inventado.")],
            [("Lin", "O nÃºcleo fez um barulho estranho. Acho que ele riu."),
             ("Kaelen", "Se ele rir mais, explode."),
             ("Elara", "Ok, sem pÃ¢nico. SÃ³... pense em vibraÃ§Ãµes.")],
            [("Roric", "Nada ainda. O nÃºcleo parece ofendido."),
             ("Kaelen", "Isso foi quase doloroso de ver."),
             ("Lin", "Tenta alguma coisa que lembre som, frequÃªncia... ou mÃºsica.")],
            [("Elara", "JÃ¡ testamos quase tudo. Quer tentar 'RESSONANCIA' logo?"),
             ("Roric", "Sim, talvez algo nessa linha... sem acento, talvez?"),
             ("Kaelen", "Vai que Ã© isso. Pior que isso nÃ£o fica.")],
        ]
        reacoes = opcoes[min(tentativas - 1, len(opcoes) - 1)]
        for nome, fala_texto in reacoes:
            fala(nome, fala_texto)

    def executar(self):
        limpar_tela()
        console.print(Panel.fit("[bold cyan]ðŸ“œ Parte 3 - A Busca pela Palavra de Sintonia[/bold cyan]", border_style="cyan"))
        fala("Kaelen", "O Tratado voltou a nÃ³s, mas o NÃºcleo vibra com instabilidade crescente.")
        fala("Elara", "Entre os trechos, hÃ¡ menÃ§Ãµes a harmonia e frequÃªncia. Pode haver uma palavra de sintonia escondida.")
        fala("Roric", "Se ela estiver lÃ¡, o Rabin-Karp pode encontrÃ¡-la entre o ruÃ­do.")
        fala("Lin", "O NÃºcleo estÃ¡ quase colapsando. Precisamos agir.")
        progresso_ritual("Conectando scanners lexicais ao NÃºcleo...", 4, 0.25)
        tentativas = 0

        while True:
            tentativa = console.input("\n[cyan]Digite a palavra que deseja procurar no Tratado (dica: pense em 'harmonia'):[/cyan] ").strip()
            if not tentativa:
                fala("Elara", "Precisamos de uma palavra concreta para vasculhar o texto.")
                continue

            tentativas += 1
            self.animacao_hash(self.texto, tentativa)
            resultados, tempo_total = self.busca_rabin(self.texto, tentativa)
            n = len(self.texto)
            m = len(tentativa)

            if resultados:
                fala("Kaelen", f"'{tentativa.upper()}' localizado. O nÃºcleo emite um eco harmÃ´nico.")
                for pos in resultados:
                    contexto = self.texto[max(0, pos - 60):min(len(self.texto), pos + 160)]
                    console.print(Panel.fit(f"[bold magenta]Trecho identificado:[/bold magenta]\n{contexto}", border_style="magenta"))
                self.analise_complexidade(n, m, tempo_total, sucesso=True)

                if self.normalizar(tentativa) == self.normalizar(self.palavra_chave):
                    self.animacao_estabiliza()
                    fala("Elara", "O trecho revela instruÃ§Ãµes de restauraÃ§Ã£o: CompressÃ£o HarmÃ´nica com Huffman e indexaÃ§Ã£o via HASH-42.")
                    fala("Roric", "NÃ£o Ã© magia. Ã‰ o protocolo de recuperaÃ§Ã£o Zephyriano. Vamos aplicar.")
                    console.print(Panel.fit("[bold cyan]ðŸš€ PrÃ³xima Fase: CompressÃ£o e IndexaÃ§Ã£o (Huffman & Hashing)[/bold cyan]", border_style="cyan"))
                    esperar_enter()
                    break
                else:
                    fala("Roric", "HÃ¡ eco, mas nÃ£o a sintonia certa. Continuem.")
                    self.reacao_erro(tentativa, tentativas)
            else:
                fala("Lin", f"'{tentativa.upper()}' nÃ£o provocou resposta. O NÃºcleo se distorce.")
                self.animacao_instavel()
                self.analise_complexidade(n, m, tempo_total, sucesso=False)
                self.reacao_erro(tentativa, tentativas)
